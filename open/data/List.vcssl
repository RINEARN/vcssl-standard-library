encode UTF-8;

/* --------------------------------------------------
 * Open VCSSL API Library ( www.vcssl.org/api/open )
 * --------------------------------------------------
 * open.data.List 1.0.3
 * リストデータ構造ライブラリ
 *
 * Spec: ---
 * Note: ---
 *
 * License: --- ( Public Domain )
 * -------------------------------------------------- */



/**
 * リストとして扱う構造体です。
 * @author 松井文宏
 */
public struct List<Type>{
	int size = 0;
	Type data[1];
}



/**
 * 要素を全て削除します。
 * @author 松井文宏
 */
public void clear<Type>( List<Type> &list ){
	alloc[0] list.data;
	alloc[1] list.data;
	list.size = 0;
}



/**
 * 使用中のサイズを返します。
 * @author 松井文宏
 */
public int size<Type>( List<Type> &list ){
	return list.size;
}



/**
 * リストの末尾に要素を追加します。
 * @author 松井文宏
 */
public void add<Type>( List<Type> &list, Type value ){
	setProperLength<Type>(list);
	list.data[ list.size++ ] = value;
}



/**
 * 特定インデックスの要素を取得します。
 * @author 松井文宏
 */
public Type get<Type>( List<Type> &list, int index ){
	if(list.size <= index){
		error("Listのインデックスが領域外を指定しました。");
		exit();
	}
	return list.data[ index ];
}



/**
 * 特定インデックスの要素を代入します。
 * @author 松井文宏
 */
public void set<Type>( List<Type> &list, int index, Type element ){
	if(list.size <= index){
		error("Listのインデックスが領域外を指定しました。");
		exit();
	}
	list.data[ index ] = element;
}



/**
 * 特定インデックスに要素を挿入します。
 * @author 松井文宏
 */
public Type insert<Type>( List<Type> &list, int index, Type value ){
	if(list.size <= index){
		error("Listのインデックスが領域外を指定しました。");
		exit();
	}
	int n = list.size;
	list.size++;
	setProperLength<Type>(list);
	for(int i=n-1; index<=i; i--){
		list.data[ i+1 ] = list.data[ i ];
	}
	list.data[ index ] = value;
}



/**
 * 指定された要素を含んでいるか判定します。
 * @author 松井文宏
 */
public bool contains<Type>( List<Type> &list, Type element ){
	int n = list.size;
	for(int i=0; i<n; i++){
		if(list.data[i] == element){
			return true;
		}
	}
	return false;
}



/**
 * 特定インデックスの要素を削除します。
 * @author 松井文宏
 */
public Type removeAt<Type>( List<Type> &list, int index ){
	if(list.size <= index){
		error("Listのインデックスが領域外を指定しました。");
		exit();
	}
	int n = list.size;
	for(int i=index; i<n-1; i++){
		list.data[ i ] = list.data[ i+1 ];
	}
	list.size--;
	setProperLength<Type>(list);
}



/**
 * 指定された要素を削除します。
 * @author 松井文宏
 */
public void remove<Type>( List<Type> &list, Type element ){
	int index = indexOf<Type>(list, element);
	if(0 <= index){
		removeAt<Type>(list, index);
	}
}



/**
 * 指定された要素を全て削除します。
 * @author 松井文宏
 */
public void removeAll<Type>( List<Type> &list, Type element ){
	int index = indexOf<Type>(list, element);
	while( 0 <= (index = indexOf<Type>(list, element)) ){
		removeAt<Type>(list, index);
	}
}



/**
 * 指定された要素を検索し、存在すればそのインデックスを、存在しなければ-1を返します。
 * @author 松井文宏
 */
public int indexOf<Type>( List<Type> &list, Type element ){
	int n = list.size;
	for(int i=0; i<n; i++){
		if(list.data[i] == element){
			return i;
		}
	}
	return -1;
}



/**
 * 指定された要素を検索し、存在すればそのインデックスを、存在しなければ-1を返します。
 * @author 松井文宏
 */
public int indexOf<Type>( List<Type> &list, Type element, int from ){
	int n = list.size;
	if(n <= from){
		error("Listの検索開始インデックスが領域外を指定しました。");
	}
	for(int i=from; i<n; i++){
		if(list.data[i] == element){
			return i;
		}
	}
	return -1;
}



/**
 * 指定された要素を後方から検索し、存在すればそのインデックスを、存在しなければ-1を返します。
 * @author 松井文宏
 */
public int lastIndexOf<Type>( List<Type> &list, Type element ){
	int n = list.size;
	for(int i=n-1; 0<=n; i--){
		if(list.data[i] == element){
			return i;
		}
	}
	return -1;
}



/**
 * 指定された要素を後方から検索し、存在すればそのインデックスを、存在しなければ-1を返します。
 * @author 松井文宏
 */
public int lastIndexOf<Type>( List<Type> &list, Type element, int from ){
	int n = list.size;
	if(from <= 0){
		error("Listの検索開始インデックスが領域外を指定しました。");
	}
	for(int i=from; 0<=i; i--){
		if(list.data[i] == element){
			return i;
		}
	}
	return -1;
}



/**
 * 全要素の順序を反転させます。
 * @author 松井文宏
 */
public void reverse<Type>( List<Type> &list ){
	int n = list.size;
	Type data[] = list.data;
	Type rev[n];
	for(int i=0; i<n; i++){
		rev[i] = data[n-1-i];
	}
	list.data = rev;
}



/**
 * 全要素を格納する配列を返します。
 * @author 松井文宏
 */
public Type[] toArray<Type>( List<Type> &list ){
	Type array[] = list.data;
	alloc[ list.size ] array;
	return array;
}



/**
 * 使用中のサイズに適切な配列バッファ長を設定します。
 * @author 松井文宏
 */
private void setProperLength<Type>( List<Type> &list ){
	int zero = 0;
	int length = length( list.data, zero );
	int properLength = getProperLength(length, list.size);
	if(properLength != length){
		alloc[ properLength ] list.data;
	}
}



/**
 * 使用中の要素数に最適なリストバッファ長を返します。
 * @author 松井文宏
 */
private int getProperLength(int length, int size){
	if( length == 0 ){
		return 1;
	}else if( length <= size ){
		while( length <= size ){
			length *= 2;
		}
		return length;
	}else if( size < length/2 ){
		while( size < length ){
			length /= 2;
		}
		return length;
	}else{
		return length;
	}
}

